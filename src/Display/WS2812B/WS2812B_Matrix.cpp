#ifdef MODULE_DISPLAY
#include "WS2812B_Matrix.h"
#if defined(ESP8266)                // -----------------  ESP8266  -----------------
  #include <ESP8266WebServer.h>
#elif defined(ESP32)                // -----------------  ESP32  -----------------
  #include <WebServer.h>
#endif                              // -------------------------------------------

// external variables
extern time_t adjustedTime;


#define LED_PIN 0
#define COLOR_ORDER GRB
#define CHIPSET WS2812B
#define POWER_VOLTAGE 5             // set Voltage
#define MAX_POWER_MILLIAMPS 700     // set Milliamps

byte maxBrightness = 35;
// Display ON/OFF
byte displayON = 1;

// Params for width and height
const uint8_t kMatrixWidth = 32;
const uint8_t kMatrixHeight = 8;
#define NUM_LEDS (kMatrixWidth * kMatrixHeight)

// Param for different pixel layouts
const bool kMatrixSerpentineLayout = true;
const bool kMatrixVertical = true;

CRGB leds_plus_safety_pixel[ NUM_LEDS + 1];
CRGB* const leds( leds_plus_safety_pixel + 1);

CRGB displayColor = CRGB(255, 0 , 0);         // Red default

// TimeZone is adjustable in config.json
int timeZone = 1; 
long timeZoneOffset;                          // Adjust for your timezone +1 - in Setup after config

unsigned long displayInterval = 1000;         // Interval for display - default
unsigned long dispPrevMils = displayInterval;

unsigned long displayRotateInterval = 10000;  // Interval for rotating display - default
unsigned long lastDisplayChange = 0;
byte displayMode = 0;

CRGB tempBufferText[NUM_LEDS];            // Buffer for text
CRGB tempBufferParticles[NUM_LEDS];       // Buffer for particles
CRGB tempBufferDate[NUM_LEDS];            // Buffer for date

CRGB *displayBuffer = nullptr;            // Pointer to store the SCROLL MESSAGE buffer
int bufferSize = 0;
//CRGB tempBufferMessage[NUM_LEDS];       // Buffer for message - not in use


// PARTICLES for FIREWORKS
// Global variables for initial velocity, gradual deceleration, and other parameters
const float INITIAL_VELOCITY = 1.5;
const float DECELERATION_FACTOR = 0.75;
const int PARTICLE_LIFE = 70;
const int PARTICLE_COUNT = 20;
const int EXPLOSION_FREQUENCY = 2; // 0 - 9 : 0 = no explosion, 9 = explosion every time
const int UPDATE_RATE = 50;


const char* messageDisplay = "";
static int scrollPosition = 0;              // Make scrollPosition static
bool messageON = false;
bool messageWinON = false;                  // Use for Enter WIN and Fireworks
bool renderWIN = false;                     // Set renderWIN to false
const long intervalMessage = 30;            // Update rate for displayMessage in milliseconds
unsigned long previousMillisMessage = 0;
unsigned long displayMessageLife = 10000;   // Interval for Message Life
unsigned long prevMilMesLife = 0;

unsigned long previousMillisText = 0;
unsigned long previousMillisParticles = 0;
const long intervalText = 50;            // Update rate for drawText in milliseconds
const long intervalParticles = UPDATE_RATE; // Update rate for addParticles in milliseconds

//MQTT Topics used from config.json
char mqtt_Brightness[120];
char mqtt_Color[120];
char mqtt_displayON[120];

const byte W_coords[][2] = {
  {23, 1}, {23, 2}, {23, 3}, {23, 4}, {23, 5}, {23, 6},
  {22, 1}, {22, 2}, {22, 3}, {22, 4}, {22, 5}, {22, 6},
  {18, 1}, {18, 2}, {18, 3}, {18, 4}, {18, 5}, {18, 6},
  {17, 1}, {17, 2}, {17, 3}, {17, 4}, {17, 5}, {17, 6},
  {21, 5}, {21, 4}, {20, 4}, {20, 3}, {19, 5}, {19, 4}
};

const byte I_coords[][2] = {
  {15, 1}, {15, 2}, {15, 3}, {15, 4}, {15, 5}, {15, 6},
  {14, 1}, {14, 2}, {14, 3}, {14, 4}, {14, 5}, {14, 6}
};

const byte N_coords[][2] = {
  {12, 1}, {12, 2}, {12, 3}, {12, 4}, {12, 5}, {12, 6},
  {11, 1}, {11, 2}, {11, 3}, {11, 4}, {11, 5}, {11, 6},
  {8, 1}, {8, 2}, {8, 3}, {8, 4}, {8, 5}, {8, 6},
  {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6},
  {10, 3}, {10, 4}, {9, 4}, {9, 5}
};

const uint8_t FontHeight=8;
const uint8_t FontWidth=6;
const static uint8_t PROGMEM Font[256][6]={
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x00
{0x00,0x3E,0x45,0x51,0x45,0x3E},	// 0x01
{0x00,0x3E,0x6B,0x6F,0x6B,0x3E},	// 0x02
{0x00,0x1C,0x3E,0x7C,0x3E,0x1C},	// 0x03
{0x00,0x18,0x3C,0x7E,0x3C,0x18},	// 0x04
{0x00,0x30,0x36,0x7F,0x36,0x30},	// 0x05
{0x00,0x18,0x5C,0x7E,0x5C,0x18},	// 0x06
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x07
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x08
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x09
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x0A
{0x00,0x30,0x48,0x4A,0x36,0x0E},	// 0x0B
{0x00,0x06,0x29,0x79,0x29,0x06},	// 0x0C
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x0D
{0x00,0x60,0x7E,0x0A,0x35,0x3F},	// 0x0E
{0x00,0x2A,0x1C,0x36,0x1C,0x2A},	// 0x0F
{0x00,0x00,0x7F,0x3E,0x1C,0x08},	// 0x10
{0x00,0x08,0x1C,0x3E,0x7F,0x00},	// 0x11
{0x00,0x14,0x36,0x7F,0x36,0x14},	// 0x12
{0x00,0x00,0x5F,0x00,0x5F,0x00},	// 0x13
{0x00,0x06,0x09,0x7F,0x01,0x7F},	// 0x14
{0x00,0x22,0x4D,0x55,0x59,0x22},	// 0x15
{0x00,0x60,0x60,0x60,0x60,0x00},	// 0x16
{0x00,0x14,0xB6,0xFF,0xB6,0x14},	// 0x17
{0x00,0x04,0x06,0x7F,0x06,0x04},	// 0x18
{0x00,0x10,0x30,0x7F,0x30,0x10},	// 0x19
{0x00,0x08,0x08,0x3E,0x1C,0x08},	// 0x1A
{0x00,0x08,0x1C,0x3E,0x08,0x08},	// 0x1B
{0x00,0x78,0x40,0x40,0x40,0x40},	// 0x1C
{0x00,0x08,0x3E,0x08,0x3E,0x08},	// 0x1D
{0x00,0x30,0x3C,0x3F,0x3C,0x30},	// 0x1E
{0x00,0x03,0x0F,0x3F,0x0F,0x03},	// 0x1F
{0x00,0x00,0x00,0x00,0x00,0x00},	// 0x20
{0x00,0x00,0x06,0x5F,0x06,0x00},	// 0x21
{0x00,0x07,0x03,0x00,0x07,0x03},	// 0x22
{0x00,0x24,0x7E,0x24,0x7E,0x24},	// 0x23
{0x00,0x24,0x2B,0x6A,0x12,0x00},	// 0x24
{0x00,0x63,0x13,0x08,0x64,0x63},	// 0x25
{0x00,0x36,0x49,0x56,0x20,0x50},	// 0x26
{0x00,0x00,0x07,0x03,0x00,0x00},	// 0x27
{0x00,0x00,0x3E,0x41,0x00,0x00},	// 0x28
{0x00,0x00,0x41,0x3E,0x00,0x00},	// 0x29
{0x00,0x08,0x3E,0x1C,0x3E,0x08},	// 0x2A
{0x00,0x08,0x08,0x3E,0x08,0x08},	// 0x2B
{0x00,0x00,0xE0,0x60,0x00,0x00},	// 0x2C
{0x00,0x08,0x08,0x08,0x08,0x08},	// 0x2D
{0x00,0x00,0x60,0x60,0x00,0x00},	// 0x2E
{0x00,0x20,0x10,0x08,0x04,0x02},	// 0x2F
{0x7E,0xFF,0x81,0x81,0xFF,0x7E},  // 0x30  0
{0x00,0x82,0xFF,0xFF,0x80,0x00},  // 0x31  1
{0xC2,0xE3,0xB1,0x99,0x8F,0x86},  // 0x32  2
{0x42,0xC3,0x89,0x89,0xFF,0x76},  // 0x33  3
{0x38,0x3C,0x26,0xF3,0xF1,0x20},  // 0x34  4
{0x4F,0xCF,0x89,0x89,0xF9,0x71},  // 0x35  5
{0x7E,0xFF,0x89,0x89,0xFB,0x72},  // 0x36  6
{0x01,0x01,0xF1,0xF9,0x0F,0x07},  // 0x37  7
{0x76,0xFF,0x89,0x89,0xFF,0x76},  // 0x38  8
{0x4E,0xDF,0x91,0x91,0xFF,0x7E},  // 0x39  9
{0x00,0x00,0x6C,0x6C,0x00,0x00},	// 0x3A
{0x00,0x00,0xEC,0x6C,0x00,0x00},	// 0x3B
{0x00,0x08,0x14,0x22,0x41,0x00},	// 0x3C
{0x00,0x24,0x24,0x24,0x24,0x24},	// 0x3D
{0x00,0x00,0x41,0x22,0x14,0x08},	// 0x3E
{0x00,0x02,0x01,0x59,0x09,0x06},	// 0x3F
{0x00,0x3E,0x41,0x5D,0x55,0x1E},	// 0x40
{0x00,0xfc,0x12,0x12,0x12,0xfc},	// 0x41 - A
{0x00,0xfe,0x92,0x92,0x92,0x6c},	// 0x42 - B
{0x00,0x7c,0x82,0x82,0x82,0x44},	// 0x43 - C
{0x00,0xfe,0x82,0x82,0x82,0x7c},	// 0x44 - D
{0x00,0xfe,0x92,0x92,0x92,0x82},	// 0x45 - E
{0x00,0xfe,0x12,0x12,0x12,0x02},	// 0x46 - F
{0x00,0x7c,0x82,0x92,0x92,0x74},	// 0x47 - G
{0x00,0xfe,0x10,0x10,0x10,0xfe},	// 0x48 - H
{0x00,0x00,0x82,0xfe,0x82,0x00},	// 0x49 - I
{0x00,0x60,0x80,0x80,0x80,0x7e},	// 0x4a - J
{0x00,0xfe,0x10,0x28,0x44,0x82},	// 0x4b - K
{0x00,0xfe,0x80,0x80,0x80,0x80},	// 0x4c - L
{0x00,0xfe,0x04,0x08,0x04,0xfe},	// 0x4d - M
{0x00,0xfe,0x04,0x08,0x10,0xfe},	// 0x4e - N
{0x00,0x7c,0x82,0x82,0x82,0x7c},	// 0x4f - O
{0x00,0xfe,0x12,0x12,0x12,0x0c},	// 0x50 - P
{0x00,0x7c,0x82,0xa2,0x42,0xbc},	// 0x51 - Q
{0x00,0xfe,0x12,0x12,0x32,0xcc},	// 0x52 - R
{0x00,0x4c,0x92,0x92,0x92,0x64},	// 0x53 - S
{0x00,0x02,0x02,0xfe,0x02,0x02},	// 0x54 - T
{0x00,0x7e,0x80,0x80,0x80,0x7e},	// 0x55 - U
{0x00,0x3e,0x40,0x80,0x40,0x3e},	// 0x56 - V
{0x00,0x7e,0x80,0x78,0x80,0x7e},	// 0x57 - W
{0x00,0xc6,0x28,0x10,0x28,0xc6},	// 0x58 - X
{0x00,0x0e,0x10,0xe0,0x10,0x0e},	// 0x59 - Y
{0x00,0xe2,0x92,0x8a,0x86,0x00},	// 0x5a - Z
{0x00,0x00,0x7F,0x41,0x41,0x00},	// 0x5B
{0x00,0x02,0x04,0x08,0x10,0x20},	// 0x5C
{0x00,0x00,0x41,0x41,0x7F,0x00},	// 0x5D
{0x00,0x04,0x02,0x01,0x02,0x04},	// 0x5E
{0x80,0x80,0x80,0x80,0x80,0x80},	// 0x5F
{0x00,0x00,0x03,0x07,0x00,0x00},	// 0x60
{0x00,0x20,0x54,0x54,0x54,0x78},	// 0x61
{0x00,0x7F,0x44,0x44,0x44,0x38},	// 0x62
{0x00,0x38,0x44,0x44,0x44,0x28},	// 0x63
{0x00,0x38,0x44,0x44,0x44,0x7F},	// 0x64
{0x00,0x38,0x54,0x54,0x54,0x08},	// 0x65
{0x00,0x08,0x7E,0x09,0x09,0x00},	// 0x66
{0x00,0x18,0xA4,0xA4,0xA4,0x7C},	// 0x67
{0x00,0x7F,0x04,0x04,0x78,0x00},	// 0x68
{0x00,0x00,0x00,0x7D,0x40,0x00},	// 0x69
{0x00,0x40,0x80,0x84,0x7D,0x00},	// 0x6A
{0x00,0x7F,0x10,0x28,0x44,0x00},	// 0x6B
{0x00,0x00,0x00,0x7F,0x40,0x00},	// 0x6C
{0x00,0x7C,0x04,0x18,0x04,0x78},	// 0x6D
{0x00,0x7C,0x04,0x04,0x78,0x00},	// 0x6E
{0x00,0x38,0x44,0x44,0x44,0x38},	// 0x6F
{0x00,0xFC,0x44,0x44,0x44,0x38},	// 0x70
{0x00,0x38,0x44,0x44,0x44,0xFC},	// 0x71
{0x00,0x44,0x78,0x44,0x04,0x08},	// 0x72
{0x00,0x08,0x54,0x54,0x54,0x20},	// 0x73
{0x00,0x04,0x3E,0x44,0x24,0x00},	// 0x74
{0x00,0x3C,0x40,0x20,0x7C,0x00},	// 0x75
{0x00,0x1C,0x20,0x40,0x20,0x1C},	// 0x76
{0x00,0x3C,0x60,0x30,0x60,0x3C},	// 0x77
{0x00,0x6C,0x10,0x10,0x6C,0x00},	// 0x78
{0x00,0x9C,0xA0,0x60,0x3C,0x00},	// 0x79
{0x00,0x64,0x54,0x54,0x4C,0x00},	// 0x7A
{0x00,0x08,0x3E,0x41,0x41,0x00},	// 0x7B
{0x00,0x00,0x00,0x77,0x00,0x00},	// 0x7C
{0x00,0x00,0x41,0x41,0x3E,0x08},	// 0x7D
{0x00,0x02,0x01,0x02,0x01,0x00},	// 0x7E
{0x00,0x3C,0x26,0x23,0x26,0x3C},	// 0x7F
{0x00,0x1E,0xA1,0xE1,0x21,0x12},	// 0x80
{0x00,0x3D,0x40,0x20,0x7D,0x00},	// 0x81
{0x00,0x38,0x54,0x54,0x55,0x09},	// 0x82
{0x00,0x20,0x55,0x55,0x55,0x78},	// 0x83
{0x00,0x20,0x55,0x54,0x55,0x78},	// 0x84
{0x00,0x20,0x55,0x55,0x54,0x78},	// 0x85
{0x00,0x20,0x57,0x55,0x57,0x78},	// 0x86
{0x00,0x1C,0xA2,0xE2,0x22,0x14},	// 0x87
{0x00,0x38,0x55,0x55,0x55,0x08},	// 0x88
{0x00,0x38,0x55,0x54,0x55,0x08},	// 0x89
{0x00,0x4c,0x93,0x92,0x93,0x64},	// 0x8A
{0x00,0x00,0x01,0x7C,0x41,0x00},	// 0x8B
{0x00,0x00,0x01,0x7D,0x41,0x00},	// 0x8C
{0x00,0x00,0x01,0x7C,0x40,0x00},	// 0x8D
{0x00,0xe2,0x93,0x8b,0x86,0x00},	// 0x8E
{0x00,0x78,0x2F,0x25,0x2F,0x78},	// 0x8F
{0x00,0x7C,0x54,0x54,0x55,0x45},	// 0x90
{0x00,0x34,0x54,0x7C,0x54,0x58},	// 0x91
{0x00,0x7E,0x09,0x7F,0x49,0x49},	// 0x92
{0x00,0x38,0x45,0x45,0x39,0x00},	// 0x93
{0x00,0x38,0x45,0x44,0x39,0x00},	// 0x94
{0x00,0x39,0x45,0x44,0x38,0x00},	// 0x95
{0x00,0x3C,0x41,0x21,0x7D,0x00},	// 0x96
{0x00,0x3D,0x41,0x20,0x7C,0x00},	// 0x97
{0x00,0x9C,0xA1,0x60,0x3D,0x00},	// 0x98
{0x00,0x3D,0x42,0x42,0x3D,0x00},	// 0x99
{0x00,0x08,0x55,0x56,0x55,0x20},	// 0x9A
{0x80,0x70,0x68,0x58,0x38,0x04},	// 0x9B
{0x00,0x48,0x3E,0x49,0x49,0x62},	// 0x9C
{0x00,0x7E,0x61,0x5D,0x43,0x3F},	// 0x9D
{0x00,0x65,0x56,0x55,0x4c,0x00},	// 0x9E
{0x00,0x40,0x88,0x7E,0x09,0x02},	// 0x9F
{0x00,0x20,0x54,0x55,0x55,0x78},	// 0xA0
{0x00,0x00,0x00,0x7D,0x41,0x00},	// 0xA1
{0x00,0x38,0x44,0x45,0x39,0x00},	// 0xA2
{0x00,0x3C,0x40,0x21,0x7D,0x00},	// 0xA3
{0x00,0x7A,0x09,0x0A,0x71,0x00},	// 0xA4
{0x00,0x7A,0x11,0x22,0x79,0x00},	// 0xA5
{0x00,0x08,0x55,0x55,0x55,0x5E},	// 0xA6
{0x00,0x4E,0x51,0x51,0x4E,0x00},	// 0xA7
{0x00,0x30,0x48,0x4D,0x40,0x20},	// 0xA8
{0x3E,0x41,0x5D,0x4B,0x55,0x3E},	// 0xA9
{0x04,0x04,0x04,0x04,0x04,0x1C},	// 0xAA
{0x00,0x17,0x08,0x4C,0x6A,0x50},	// 0xAB
{0x00,0x17,0x08,0x34,0x2A,0x78},	// 0xAC
{0x00,0x00,0x30,0x7D,0x30,0x00},	// 0xAD
{0x00,0x08,0x14,0x00,0x08,0x14},	// 0xAE
{0x00,0x14,0x08,0x00,0x14,0x08},	// 0xAF
{0x44,0x11,0x44,0x11,0x44,0x11},	// 0xB0
{0xAA,0x55,0xAA,0x55,0xAA,0x55},	// 0xB1
{0xBB,0xEE,0xBB,0xEE,0xBB,0xEE},	// 0xB2
{0x00,0x00,0x00,0xFF,0x00,0x00},	// 0xB3
{0x08,0x08,0x08,0xFF,0x00,0x00},	// 0xB4
{0x00,0x70,0x28,0x25,0x29,0x70},	// 0xB5
{0x00,0x70,0x29,0x25,0x29,0x70},	// 0xB6
{0x00,0x70,0x29,0x25,0x28,0x70},	// 0xB7
{0x3E,0x41,0x5D,0x55,0x41,0x3E},	// 0xB8
{0x0A,0xFB,0x00,0xFF,0x00,0x00},	// 0xB9
{0x00,0xFF,0x00,0xFF,0x00,0x00},	// 0xBA
{0x0A,0xFA,0x02,0xFE,0x00,0x00},	// 0xBB
{0x0A,0x0B,0x08,0x0F,0x00,0x00},	// 0xBC
{0x00,0x18,0x24,0x66,0x24,0x00},	// 0xBD
{0x00,0x29,0x2A,0x7C,0x2A,0x29},	// 0xBE
{0x08,0x08,0x08,0xF8,0x00,0x00},	// 0xBF
{0x00,0x00,0x00,0x0F,0x08,0x08},	// 0xC0
{0x08,0x08,0x08,0x0F,0x08,0x08},	// 0xC1
{0x08,0x08,0x08,0xF8,0x08,0x08},	// 0xC2
{0x00,0x00,0x00,0xFF,0x08,0x08},	// 0xC3
{0x08,0x08,0x08,0x08,0x08,0x08},	// 0xC4
{0x08,0x08,0x08,0xFF,0x08,0x08},	// 0xC5
{0x00,0x7c,0x82,0x82,0x83,0x44},	// 0xC6
{0x00,0x70,0x2A,0x25,0x2A,0x71},	// 0xC7
{0x00,0x7c,0x83,0x82,0x83,0x44},	// 0xC8
{0x00,0xFE,0x02,0xFA,0x0A,0x0A},	// 0xC9
{0x0A,0x0B,0x08,0x0B,0x0A,0x0A},	// 0xCA
{0x0A,0xFA,0x02,0xFA,0x0A,0x0A},	// 0xCB
{0x00,0xFF,0x00,0xFB,0x0A,0x0A},	// 0xCC
{0x0A,0x0A,0x0A,0x0A,0x0A,0x0A},	// 0xCD
{0x0A,0xFB,0x00,0xFB,0x0A,0x0A},	// 0xCE
{0x00,0x5D,0x22,0x22,0x22,0x5D},	// 0xCF
{0x10,0xfe,0x92,0x82,0x82,0x7c},	// 0xD0
{0x00,0x08,0x7F,0x49,0x41,0x3E},	// 0xD1
{0x00,0x7C,0x55,0x55,0x55,0x44},	// 0xD2
{0x00,0x7C,0x55,0x54,0x55,0x44},	// 0xD3
{0x00,0x7C,0x55,0x55,0x54,0x44},	// 0xD4
{0x00,0x00,0x00,0x07,0x00,0x00},	// 0xD5
{0x00,0x00,0x44,0x7D,0x45,0x00},	// 0xD6
{0x00,0x00,0x45,0x7D,0x45,0x00},	// 0xD7
{0x00,0x00,0x45,0x7C,0x45,0x00},	// 0xD8
{0x08,0x08,0x08,0x0F,0x00,0x00},	// 0xD9
{0x00,0x00,0x00,0xF8,0x08,0x08},	// 0xDA
{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},	// 0xDB
{0xF0,0xF0,0xF0,0xF0,0xF0,0xF0},	// 0xDC
{0x00,0x00,0x00,0x77,0x00,0x00},	// 0xDD
{0x00,0x00,0x45,0x7D,0x44,0x00},	// 0xDE
{0x0F,0x0F,0x0F,0x0F,0x0F,0x0F},	// 0xDF
{0x00,0x3C,0x42,0x43,0x3D,0x00},	// 0xE0
{0x00,0xFE,0x4A,0x4A,0x34,0x00},	// 0xE1
{0x00,0x3C,0x43,0x43,0x3D,0x00},	// 0xE2
{0x00,0x3D,0x43,0x42,0x3C,0x00},	// 0xE3
{0x00,0x32,0x49,0x4A,0x31,0x00},	// 0xE4
{0x00,0x3A,0x45,0x46,0x39,0x00},	// 0xE5
{0x00,0x38,0x44,0x46,0x45,0x28},	// 0xE6
{0x00,0xFE,0xAA,0x28,0x10,0x00},	// 0xE7
{0x00,0x38,0x45,0x46,0x45,0x28},	// 0xE8
{0x00,0x3C,0x40,0x41,0x3D,0x00},	// 0xE9
{0x00,0x3C,0x41,0x41,0x3D,0x00},	// 0xEA
{0x00,0x3D,0x41,0x40,0x3C,0x00},	// 0xEB
{0x00,0x9C,0xA0,0x61,0x3D,0x00},	// 0xEC
{0x00,0x04,0x08,0x71,0x09,0x04},	// 0xED
{0x00,0x00,0x02,0x02,0x02,0x00},	// 0xEE
{0x00,0x00,0x07,0x03,0x00,0x00},	// 0xEF
{0x38,0x44,0x44,0x45,0x7f,0x01},	// 0xF0
{0x00,0x00,0x24,0x2E,0x24,0x00},	// 0xF1
{0x00,0x24,0x24,0x24,0x24,0x24},	// 0xF2
{0x05,0x17,0x0A,0x34,0x2A,0x78},	// 0xF3
{0x00,0x06,0x09,0x7F,0x01,0x7F},	// 0xF4
{0x00,0x22,0x4D,0x55,0x59,0x22},	// 0xF5
{0x00,0x08,0x08,0x2A,0x08,0x08},	// 0xF6
{0x00,0x00,0x08,0x18,0x18,0x00},	// 0xF7
{0x00,0x06,0x09,0x09,0x06,0x00},	// 0xF8
{0x00,0x00,0x08,0x00,0x08,0x00},	// 0xF9
{0x00,0x00,0x08,0x00,0x00,0x00},	// 0xFA
{0x00,0x02,0x0F,0x00,0x00,0x00},	// 0xFB
{0x00,0x09,0x0F,0x05,0x00,0x00},	// 0xFC
{0x00,0x09,0x0D,0x0A,0x00,0x00},	// 0xFD
{0x00,0x3C,0x3C,0x3C,0x3C,0x00},	// 0xFE
{0x00,0x00,0x00,0x00,0x00,0x00} 	// 0xFF
};

/* ======================================================================
Function: updateDisplay
Purpose : Main Display Constructor 
Input   : None
Output  : None
Comments: Updates the display with time, date, temperature, humidity, or message based on the current state.
TODO    : */
void updateDisplay()
{
	if ( displayON == 1 )	// if display is SET ON
	{
		unsigned long currentMillis = millis();
		if ( messageON )
		{
			if ( messageWinON )
				renderDisplayWin( currentMillis );				// Display Win message - moved to separate function
			else
				renderDisplayMessage( currentMillis );			// Display Message - moved to separate function
		}
		else
		{
			if ( currentMillis - dispPrevMils >= displayInterval )
			{
				FastLED.clearData();
				adjustedTime = now() + timeZoneOffset;	// Adjust time by Time Zone offset 
				dispPrevMils = currentMillis;
				
				if (currentMillis - lastDisplayChange >= displayRotateInterval)
				{
					lastDisplayChange = currentMillis;
					displayMode = (displayMode + 1) % 4; // Rotate between 4 display modes
				}
				
				switch (displayMode)
				{
					case 0:
							displayRotateInterval = 4000;              // 4 sec
							drawDate(tempBufferDate, 1, 0, displayColor);
							for (int i = 0; i < NUM_LEDS; i++) { leds[i] = tempBufferDate[i];}
							break;
					case 1:
							displayRotateInterval = 10000;             // 10 sec
							drawTime(1, 0, displayColor, true, false); // Display time
							break;
					case 2:
							displayRotateInterval = 5000;              // 5 sec
							drawTempHum(0, 0, displayColor, true);     // Display Temperature true
							break;
					case 3:
							displayRotateInterval = 4000;              // 4 sec
							drawTempHum(0, 0, displayColor, false);    // Display Humidity - false
							break;
				}
			}
		}
	}
	// Always show LEDs
	FastLED.show();
}

void drawLetter( int posx, int posy, char letter, CRGB color )
{
	if ((posx > -FontWidth) && (posx < kMatrixWidth))
		for (int x = 0; x < FontWidth; x++)
			for (int y = 0; y < FontHeight; y++)
				if (bitRead(pgm_read_byte(&(Font[letter][FontWidth - 1 - x])), y) == 1)
					leds[XYsafe(posx + x, posy + y)] = color;
}

void drawLetterBuf( CRGB *buffer, int posx, int posy, char letter, CRGB color )
{
	if ((posx > -FontWidth) && (posx < kMatrixWidth))
		for (int x = 0; x < FontWidth; x++)
			for (int y = 0; y < FontHeight; y++)
				if (bitRead(pgm_read_byte(&(Font[letter][FontWidth - 1 - x])), y) == 1)
					buffer[XYsafe(posx + x, posy + y)] = color;
}

void drawTempHum( int x, int y, CRGB colorText, bool isTemperature )
{
	char tmpStr[10];
	CRGB temperatureColor = CRGB(255, 0, 0);
	CRGB humidityColor = CRGB(0, 0, 255);
	temperatureColor.nscale8(maxBrightness);
	humidityColor.nscale8(maxBrightness);
	colorText.nscale8(maxBrightness);

	x = 4;
	if (isTemperature)
	{
		dtostrf(t, 3, 0, tmpStr);
		drawLetter(x, 0, 'C', temperatureColor);
		x += FontWidth - 3;
		drawLetter(x, -5, '.', temperatureColor); // Drawing '.' but move it up -5
		x += 6;
	}
	else
	{
		dtostrf(h, 3, 0, tmpStr);
		drawLetter(x, 1, '%', humidityColor);
		x += FontWidth + 1;
	}

	int length = strlen(tmpStr); // Get the length of the character array
	for (int i = 0; i < length; i++)
	{
		char letter = tmpStr[length - 1 - i]; // Reverse order
		drawLetter(x, y, letter, colorText);
		x += FontWidth + 1; // Move to the next position
	}
}

void drawTime( int x, int y, CRGB colorTime, bool colon, bool seconds )
{
    int hours = hour(adjustedTime);
    int minutes = minute(adjustedTime);
    int secs = second(adjustedTime);

	 colorTime.nscale8(maxBrightness);
    
    // Display time on LED matrix with swapped positions
    x -= 0;
    drawLetter(x, y, minutes % 10 + '0', colorTime);
    x += FontWidth + 1;
    drawLetter(x, y, minutes / 10 + '0', colorTime);
    x += FontWidth;
    if ( colon )
    {
        if ( secs % 2 == 0 )
            drawLetter(x - 1, y, ':', colorTime);
        x += 4;
    }
    drawLetter(x, y, hours % 10 + '0', colorTime);
    x += FontWidth + 1;
    drawLetter(x, y, hours / 10 + '0', colorTime);
}

void drawDate( CRGB *buffer, int x, int y, CRGB colorDate )
{
	static int lastDays = -1;
	static int lastMonths = -1;
	static CRGB lastColorDate = CRGB::Black;
	static bool initialized = false;

	// Get current date components
	int days = day(adjustedTime);
	int months = month(adjustedTime);

	// Check if it's the first run or if the date or color has changed
	if (!initialized || days != lastDays || months != lastMonths || colorDate != lastColorDate)
	{
		// Update the buffer
		memset(buffer, 0, sizeof(CRGB) * NUM_LEDS); // Clear the buffer
		colorDate.nscale8(maxBrightness);

		// Display date on LED matrix
		int posX = x;
		drawLetterBuf(buffer, posX, y, months % 10 + '0', colorDate);
		posX += FontWidth + 1;
		drawLetterBuf(buffer, posX, y, months / 10 + '0', colorDate);
		posX += FontWidth + 1;
		drawLetterBuf(buffer, posX - 2, y + 1, '.', colorDate);
		posX += 3;
		drawLetterBuf(buffer, posX, y, days % 10 + '0', colorDate);
		posX += FontWidth + 1;
		drawLetterBuf(buffer, posX, y, days / 10 + '0', colorDate);

		// Update the last known values
		lastDays = days;
		lastMonths = months;
		lastColorDate = colorDate;
		initialized = true; // Mark as initialized
	}
}

/* =======displayMessage=================================================
Function: displayMessage
Purpose : Scroll text message on the LED matrix 
Input   : buffer: buffer where to write,
			 colorScroll: color for letters,
			 message: send or predefined,
			 numSpaces: number of spaces in front of the message
Output  : Scroll
Comments: 
TODO    : */
void displayMessage( CRGB colorScroll, const char *message, int numSpaces )
{
	static bool bufferInitialized = false;
	static String previousMessage = "";
	static int previousNumSpaces = 0;
	colorScroll.nscale8(maxBrightness);

	String convertedMessage = convertToSingleByte(message);

	// Check if the message or number of spaces has changed
	if (previousMessage != convertedMessage || previousNumSpaces != numSpaces)
	{
		if  (displayBuffer != nullptr )		// Free the old buffer if it exists
			delete[] displayBuffer;

		// Calculate the new buffer size
		bufferSize = (convertedMessage.length() + numSpaces) * 6 * kMatrixHeight;
		displayBuffer = new CRGB[bufferSize];  // Allocate memory for the new buffer

		for (int i = 0; i < bufferSize; i++)	// Initialize the buffer with the new message and spaces
			displayBuffer[i] = CRGB::Black;

		// Add spaces in front of the message
		for (int i = 0; i < numSpaces; i++)
		{
			int charPosition = i * 6;
			for (int x = 0; x < 6; x++)
			{
				for (int y = 0; y < 8; y++)
				{
					int bufferIndex = (charPosition + x) + (y * (convertedMessage.length() + numSpaces) * 6);
					if (bufferIndex < bufferSize)
						displayBuffer[bufferIndex] = CRGB::Black;
				}
			}
		}

		for (int i = 0; i < convertedMessage.length(); i++)
		{
			char charToDisplay = convertedMessage.charAt(i);
			int charPosition = (i + numSpaces) * 6;
			for (int x = 0; x < 6; x++)
			{
				for (int y = 0; y < 8; y++)
				{
					if (bitRead(pgm_read_byte(&(Font[charToDisplay][x])), y) == 1)
					{
						int bufferIndex = (charPosition + x) + (y * (convertedMessage.length() + numSpaces) * 6);
						if (bufferIndex < bufferSize)
							displayBuffer[bufferIndex] = colorScroll;
					}
				}
			}
		}

		previousMessage = convertedMessage; // Update the previous message
		previousNumSpaces = numSpaces;		// Update the previous number of spaces
		scrollPosition = 0;						// Reset the scroll position
	}

	// Copy the relevant part of the buffer to the LED matrix
	for (int x = 0; x < kMatrixWidth; x++)
	{
		for (int y = 0; y < kMatrixHeight; y++)
		{
			int bufferIndex = (scrollPosition + x) % ((convertedMessage.length() + numSpaces) * 6) + (y * (convertedMessage.length() + numSpaces) * 6);
			if ( bufferIndex < bufferSize )
				leds[XYsafe(kMatrixWidth - 1 - x, y)] += displayBuffer[bufferIndex]; // Use buffer instead of leds
		}
	}

	scrollPosition++;
	if (scrollPosition >= (convertedMessage.length() + numSpaces) * 6)
		scrollPosition = 0;
}

// void freeDisplayMessageBuffer() { if (displayBuffer != nullptr) { delete[] displayBuffer; displayBuffer = nullptr; } }

void renderDisplayMessage( unsigned long currentMillis )
{
	//
	// DRAW TEXT SCROLL
	if ( currentMillis - previousMillisMessage >= intervalMessage )
	{
		FastLED.clearData();
		previousMillisMessage = currentMillis;
		//memset( tempBufferMessage, 0, sizeof(tempBufferMessage) ); // Clear temp buffer
		displayMessage( CRGB::Red, messageDisplay, 6); // Update temp buffer | using buffer if we want add something over / effect
		
		//for (int i = 0; i < NUM_LEDS; i++)	// Fill LEDS from buffer
		//	leds[i] = tempBufferMessage[i];
	}
	
	if ( currentMillis - prevMilMesLife >= displayMessageLife )
	{
		server.begin(); // We have stop it when set messageON = true in displayState()
		//memset( tempBufferMessage, 0, sizeof(tempBufferMessage) ); // Clear temp buffer
		//freeDisplayMessageBuffer(); 
		messageON = false; // Set messageON to false after 10 seconds 
	}
}

/* =======Particle======================================================
Class   : Particle
Purpose : Represents a particle with position, color, velocity, and life attributes
Members :
    - float x, y: Position of the particle
    - CRGB color: Color of the particle
    - float xvel, yvel: Velocity of the particle in the x and y directions
    - int life: Life duration of the particle

Methods :
    - Particle(float x, float y, CRGB color): Constructor to initialize the particle with position, color, and random velocity
    - void update(CRGB* buffer): Updates the particle's position, slows it down, and decreases its life
    - void draw(CRGB* buffer): Draws the particle on the buffer and updates its position
    - bool isDead(): Checks if the particle's life has ended
    - void slowDown(): Slows down the particle's velocity

Comments: 
    - The constructor initializes the particle's position, color, and velocity based on global constants.
    - The update method calls the draw method, slows down the particle, and decreases its life.
    - The draw method ensures the particle stays within bounds and updates its position.
    - The isDead method checks if the particle's life has ended.
    - The slowDown method reduces the particle's velocity using a global deceleration factor. */

Particle::Particle(float x, float y, CRGB color) {
    this->x = x;
    this->y = y;
    this->color = color;
    float velocityFactor = 100.0 / INITIAL_VELOCITY;
    this->xvel = random(-100, 100) / velocityFactor; // Use global initial velocity
    this->yvel = random(-100, 100) / velocityFactor; // Use global initial velocity
    this->life = PARTICLE_LIFE; // Use global particle life
}

void Particle::update(CRGB* buffer) {
    draw(buffer);
    slowDown();
    life -= 5;
}

void Particle::draw(CRGB* buffer) {
    // Adjust Particle brightness - 0 to 255
    color.nscale8(min(maxBrightness * 4, 255));

    // Ensure particles stay within bounds
    if (x >= 0 && x < kMatrixWidth && y >= 0 && y < kMatrixHeight) {
        int index = XYsafe(static_cast<uint8_t>(x), static_cast<uint8_t>(y));
        if (index != -1)
            buffer[index] += color; // Use additive blending
    }
    x += xvel;
    y += yvel;

    // Mark particle as dead if out of bounds
    if (x < 0 || x >= kMatrixWidth || y < 0 || y >= kMatrixHeight)
        life = -1;
}

bool Particle::isDead() {
    return life < 0;
}

void Particle::slowDown() {
    xvel *= DECELERATION_FACTOR; // Use global deceleration factor
    yvel *= DECELERATION_FACTOR; // Use global deceleration factor
}

std::vector<Particle> particles;

void resetParticles()
{
  particles.clear(); // Clear the particles vector
  // Reinitialize any other necessary variables here
}

void addParticles( CRGB* buffer )
{
	//  Continuously generate explosion particles, concentrating between rows 3 and 6
	if (random(10) < EXPLOSION_FREQUENCY)
	{
		int x = random(kMatrixWidth);
		int y = random(1, 6); // Concentrate explosions between rows 1 and 6
		CRGB color = CRGB(random(256), random(256), random(256));

		for (int i = 0; i < PARTICLE_COUNT; i++)
			particles.push_back(Particle(x, y, color));
	}

	for (size_t i = 0; i < particles.size(); i++)
	{
		particles[i].update(buffer); // Update each particle

		if (particles[i].isDead())
		{
			particles.erase(particles.begin() + i);
			i--;
		}
	}
}

void drawWIN( const byte coords[][2], int size, CRGB *buffer, CRGB color )
{
	for (int i = 0; i < size; i++)
		buffer[XYsafe(coords[i][0], coords[i][1])] = color;
}

void drawText( CRGB *buffer )
{
	static uint8_t brightness = 30;
	static bool increasing = true;

	// Draw flipped "WIN" in the center with varying brightness
	static CRGB color = CRGB(255, 0, 0);
	static uint8_t lastBrightness = 30;
	if ( brightness != lastBrightness )
	{
		color = CRGB(255, 0, 0);
		color.nscale8(brightness);
		lastBrightness = brightness;
	}

	// Draw letters using the optimized function
	drawWIN(W_coords, sizeof(W_coords) / sizeof(W_coords[0]), buffer, color);
	drawWIN(I_coords, sizeof(I_coords) / sizeof(I_coords[0]), buffer, color);
	drawWIN(N_coords, sizeof(N_coords) / sizeof(N_coords[0]), buffer, color);

	// Adjust brightness
	if ( increasing )
	{
		brightness += 30;
		if ( brightness >= min(maxBrightness*4, 255) )
			increasing = false;
	}
	else
	{
		brightness -= 30;
		if ( brightness <= 30 )
			increasing = true;
	}
}

void renderDisplayWin( unsigned long currentMillis )
{
	FastLED.clearData();
	// DRAW WIN WITH FIREWORKS
	if ( renderWIN )
	{
		if ( currentMillis - previousMillisText >= intervalText )
		{
			writeLogFile( "renderWIN", 1, 1 );
			previousMillisText = currentMillis;
			memset( tempBufferText, 0, sizeof(tempBufferText) ); // Clear temp buffer
			drawText(tempBufferText); // Update temp buffer
		}
	}
	
	// Update addParticles at its own interval
	if ( currentMillis - previousMillisParticles >= intervalParticles )
	{
		writeLogFile( "render Particle", 1, 1 );
		previousMillisParticles = currentMillis;
		memset( tempBufferParticles, 0, sizeof(tempBufferParticles) ); // Clear temp buffer
		addParticles( tempBufferParticles ); 									// Update temp buffer
	}
	
	// Combine buffers
	for (int i = 0; i < NUM_LEDS; i++)
		leds[i] = tempBufferText[i] + tempBufferParticles[i]; // Combine buffers tempBufferText[i] + 

	if ( currentMillis - prevMilMesLife >= displayMessageLife )
	{
		FastLED.clearData();
		memset( tempBufferText, 0, sizeof(tempBufferText) ); // Clear temp buffer
		memset( tempBufferParticles, 0, sizeof(tempBufferParticles) ); // Clear temp buffer
		messageON = false; // Set messageON to false after 10 seconds
		messageWinON = false;
		renderWIN = true;
		resetParticles(); // Clear the particles vector
		server.begin(); // We have stop it when set messageON = true in displayState()
	}
}
/* ======================================================================
Function: displayState
Purpose : fast update for Display Params - return JSON on status no save 
Input   : POST || Blank == return JSON
Output  : nothing || return JSON
Comments: 
TODO    : */
void displayState()
{
	char buffer[8];

	if (server.args() == 0)
	{
		char data[90];
		sprintf(buffer, "#%02X%02X%02X", displayColor.r, displayColor.g, displayColor.b);
		sprintf(data, "{\"displayON\":%d,\"Brightness\":%d,\"displayColor\":\"%s\",\"timeZone\":%d}", displayON, maxBrightness, buffer, 1);

		// 3 is indicator of JSON already formated reply
		sendJSONheaderReply(3, data);
	}
	else
	{
		// Get arg/params posted and change settings
		// timeZoneOffset, brightness, messageDisplay, displayMode
		if (server.hasArg("brightness"))
		{
			maxBrightness = server.arg("brightness").toInt();
			itoa(maxBrightness, buffer, 10); // Convert
			writeLogFile(F("Updated brightness to ") + String(maxBrightness), 1, 1);
			if (mqtt_start == 1)
				if (!sendMQTT(mqtt_Brightness, buffer, true))
					writeLogFile(F("Publish Brightness: failed"), 1);
		}

		if (server.hasArg("messageDisplay"))
		{
			messageDisplay = server.arg("messageDisplay").c_str();
			// writeLogFile( F("Updated messageDisplay to ") + String(messageDisplay), 1, 1 );
			messageON = true;
			server.stop(); // Stopping webServer because it scrambles scroll buffer if accessed during scroll
			prevMilMesLife = millis();
		}

		if (server.hasArg("color"))
		{
			String hexColor = server.arg("color");
			// Example: "#A12345"
			hexColor.toCharArray(buffer, sizeof(buffer));
			hexColor.remove(0, 1); // Remove the '#'character
			displayColor = strtoul(hexColor.c_str(), NULL, 16);
			if (mqtt_start == 1)
				if (!sendMQTT(mqtt_Color, buffer, true))
					writeLogFile(F("Publish Color: failed"), 1);
		}
		sendJSONheaderReply(1, "Updated");
	}
}

/* ======================================================================
Function: convertToSingleByte
Purpose : convert extended ASCII 2byte to SingleByte 
Input   : String input (letter)
Output  : String 
Comments: 
TODO    : */
String convertToSingleByte( String input )
{
   String output = "";
   for (int i = 0; i < input.length(); i++)
   {
      char c = input.charAt(i);
      if (c == 0xC4 || c == 0xC5)
      {
         char nextChar = input.charAt(i + 1);
         switch (nextChar)
         {
            case 0x8D: output += (char)0xE8; i++; break; // č (C4)
            case 0x8C: output += (char)0xC8; i++; break; // Č (C4)
            case 0x87: output += (char)0xE6; i++; break; // ć (C4)
            case 0x86: output += (char)0xC6; i++; break; // Ć (C4)
            case 0xBE: output += (char)0x9E; i++; break; // ž (C5)
            case 0xBD: output += (char)0x8E; i++; break; // Ž (C5)
            case 0xA1: output += (char)0x9A; i++; break; // š (C5)
            case 0xA0: output += (char)0x8A; i++; break; // Š (C5)
            case 0x91: output += (char)0xF0; i++; break; // đ (C5)
            case 0x90: output += (char)0xD0; i++; break; // Đ (C5)
            default: output += c; break;
         }
      }
      else
      {
         output += c;
      }
   }
   return output;
}

uint16_t XY(uint8_t x, uint8_t y)
{
	uint16_t i;
	if (kMatrixSerpentineLayout == false)
	{
		if (kMatrixVertical == false)
			i = (y * kMatrixWidth) + x;
		else
			i = kMatrixHeight * (kMatrixWidth - (x + 1)) + y;
	}

	if (kMatrixSerpentineLayout == true)
	{
		if (kMatrixVertical == false)
		{
			if (y & 0x01)
			{
				// Odd rows run backwards
				uint8_t reverseX = (kMatrixWidth - 1) - x;
				i = (y * kMatrixWidth) + reverseX;
			}
			else
			{
				// Even rows run forwards
				i = (y * kMatrixWidth) + x;
			}
		}
		else
		{ // vertical positioning
			if (x & 0x01)
				i = kMatrixHeight * (kMatrixWidth - (x + 1)) + y;
			else
				i = kMatrixHeight * (kMatrixWidth - x) - (y + 1);
		}
	}

	return i;
}

uint16_t XYsafe(uint8_t x, uint8_t y)
{
	if ( x >= kMatrixWidth ) return -1;
	if ( y >= kMatrixHeight ) return -1;
	if ( x < 0 ) return -1;
	if ( y < 0 ) return -1;
	return XY(x, y);
}

#endif